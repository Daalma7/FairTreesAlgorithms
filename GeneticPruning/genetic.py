from hashlib import sha256
from sklearn.datasets import load_iris
from sklearn.model_selection import cross_val_score
import numpy as np
from sklearn.metrics import accuracy_score
    

from general import Individual
from general import Individual_NSGA2



# TODO: Comentar y explicar
class Genetic_Pruning_Process():
    """
    Class that represents a genetic process.

    Parameters:
    - struc: Structure of the problem
    - population: Population of the genetic process
    - base_leaves: Representation of the leaves of the tree
    - fair_dict: Fairness structure
    - total_samples_dict: Dictionary indicating total amount of training examples that fall into each node
    - max_depth: Maximum depth of the tree
    - max_prunings: Maximum amount of prunings
    - max_indivs: Maximum amount of individuals
    - max_generations: Maximum amount of generations
    - max_accuracy: Maximum accuracy
    - max_fpr: Maximum FPR
    """

    indiv_class = Individual

    def __init__(self, struc, objs_string, num_gen, num_indiv, prob_cross, prob_mutation):
        self.struc = struc
        self.objs_string = objs_string
        self.num_gen = num_gen
        self.num_indiv = num_indiv
        self.prob_cross = prob_cross
        self.prob_mutation = prob_mutation
        self.population = None
        self.initial_population()

    def initial_population(self):
        """
        Creates the initial population. As it is defined, it may create some
        empty individuals (full tree)

        Parameters:
        - s_prob: Dictionary with the probability of each node for being selected
                in each individual. (Preferably generated by space_probs function)
        - num_indiv: Number of individuals to be generated

        Returns:
        - indivs: List of individuals forming the population
        """

        self.population = []
        space_probs = self.struc.space_probs()      # Probability of including each possible node in the new individual
        for i in range(self.num_indiv):          # For each individual to be created
            newset = []                     # Create its representation
            for a in space_probs:                # For each node in the tree
                r = np.random.rand()        # Calculate if that node will be selected (pruned)
                if r < space_probs[a]:           # If it is selected, append it to the representation
                    newset.append(a)
            
            self.population.append(Genetic_Pruning_Process.indiv_class(self.struc, self.objs_string, newset))    # Create and append the individual


    # TODO MEJORAR: Puede que haya cruces extremos en los que un árbol se queda virgen. Igualmente, puede que haya podas que se coman las unas a las otras.
    def crossover(self, indiv1, indiv2):
        """
        Crossover between 2 individuals
        
        Parameters:
        - indiv1: First individual
        - indiv2: Second individual

        Returns:
        - newindiv1: First child individual
        - newindiv2: Second child individual
        """
        
        # If both individuals represent no prunings, they will be returned
        if len(indiv1.repr) == 0 and len(indiv2.repr) == 0:
            return indiv1, indiv2

        # In any other case
        # We will take the prunings done in each individual, join them, and select randomly to which individual we be assigned.
        newlist = []
        newlist.extend(indiv1.repr)
        newlist.extend(indiv2.repr)

        newindiv1 = []
        newindiv2 = []

        # Randomly assign the prunings to the individuals, with equal probability
        for elem in newlist:
            if np.random.rand() < 0.5:
                newindiv1.append(elem)
            else:
                newindiv2.append(elem)

        return Genetic_Pruning_Process.indiv_class(self.struc, self.objs_string, newindiv1), Genetic_Pruning_Process.indiv_class(self.struc, self.objs_string, newindiv2)


    # TODO torneo binario pero teniendo en cuenta únicamente una función de objectives univariable.
    def tournament(self):
        """
        Applies tournament criterion over population, returning parents population.

        Parameters:
        - population: population of individuals to b

        Returns:
        - new_pop: parents population
        """
        
        new_pop = []    # Population of nodes winning the tournament

        longi = len(self.population)
        for i in range(longi):                      # For each individual in the new population
            rand1 = np.random.randint(0, longi)     # Randomly select two distinct individuals
            rand2 = np.random.randint(0, longi)
            while rand1 == rand2:
                rand2 = np.random.randint(0, longi)

            # We select the node with the greates objectives value.
            objectives_1 = self.population[rand1].objectives
            objectives_2 = self.population[rand2].objectives
            print(objectives_1 > objectives_2)
            if objectives_1 > objectives_2:
                new_pop.append(self.population[rand1])
            else:
                new_pop.append(self.population[rand2])

        return new_pop


    def pop_crossover(self):
        """
        Applies crossover over parents population

        Parameters:
        - population: population of parents
        - prob_cross: probability of crossover between parents

        Returns:
        - new_pop: new children population
        """
        
        new_pop = []                    # Children population

        longi = len(self.population)         
        for i in range(int(longi/2)):       # For each pair or parents
            rand = np.random.random()       # We decide if crossover will be done
            if rand < self.prob_cross:           # If so, we apply it
                new_indiv1, new_indiv2 = self.crossover(self.population[2*i], self.population[(2*i)+1])
                new_pop.append(new_indiv1)
                new_pop.append(new_indiv2)
            else:                           # If not, we return the same parents
                new_pop.append(self.population[2*i])
                new_pop.append(self.population[(2*i)+1])

        return new_pop



    def aux_random_value_prob_dict(self, prob_dict, rand):
        """
        Return an element given a probability dictionary, and a random value
        This is an auxiliary function

        Parameters:
        - prob_dict: dictionary with probabilities. They have to add up to 1
        - rand: random value between 0 and 1

        Returns:
        - k: selected key from the dictionary
        """
        total = 0
        for k, v in prob_dict.items():
            total += v
            if rand <= total:
                return k


    def mutation(self, indiv):
        """
        Applies mutations randomly over an individual. The mutations may not happen at all

        Parameters:
        - indiv: individual for which the objectives will be calculated
        - space: space of prunings
        - base_leaves: dictionary with the leaves of the base tree.
        - prob_mutation: probability of mutation

        Returns:
        - objectives_val: its objectives value
        """

        rand_modify = np.random.random()

        if rand_modify < self.prob_mutation:       # If a mutation will be done
            
            # We will calculate the nodes from which a modification of a pruning can be done
            leaves = []

            # To begin with, we will find all the leaf nodes the pruned tree has
            for leaf in self.struc.base_leaves:
                leaves.append(leaf)
            
            # After that, we will check if there is any actual pruning of the tree that is set to be done that would
            # prune any of the already calculated leaves. If so, we will have to remove the previous leaves and add the new one

            for elem in indiv.repr:                                  # Prunings done (will be add and corrected)
                # We will calculate if it covers a leaf node. If so, we will erase it
                length = len(elem)
                leaves = [leaf for leaf in leaves if leaf[:length] != elem]
            
            # We will now directly add them to the current leaves.
            for elem in indiv.repr:
                leaves.append(elem)


            # We will now randomly select one of those leaves. We will select it using equal probabilities
            probs = {leaf: 1/len(leaves) for leaf in leaves}

            leaf = self.aux_random_value_prob_dict(probs, np.random.random())         # Select one of the leaves

            # After having selected the leaf, we will now select the mutation applied over that leaf.

            new_repr = indiv.repr.copy()

            if leaf in self.struc.base_leaves:                 # If the leaf is a leaf node of the complete tree, we can only select its parent
                if len(leaf) > 1:                       # It its parent is not the root node
                    new_repr.add(leaf[:-1])                    # We directly add it to the individual
            else:                                   # In other case we can go up or down in the tree hierarchy.
                new_probs = {}                          # We will create a new space for the possible mutations
                if len(leaf) > 1:
                    new_probs[leaf[:-1]] = 1/5          # Parent node
                children = self.struc.children_nodes(leaf)
                
                # Children nodes. We have to take into account the possibility of removing the pruning if a children is a leaf node of the actual tree
                if len(children) == 2:
                    new_probs[children[0]] = 2/5
                    new_probs[children[1]] = 2/5
                elif len(children) == 1:
                    new_probs['empty'] = 2/5
                    new_probs[children[0]] = 2/5
                else:
                    new_probs['empty'] = 4/5
            
                my_sum = sum(new_probs.values())                                        # Calculate sum for probability normalization
                new_probs = {key: value/my_sum for key, value in new_probs.items()}         # Apply probability normalization

                prun = self.aux_random_value_prob_dict(new_probs, np.random.random())         # Select one of them
                new_repr.remove(leaf)                                                      # Get rid of the leaf

                if prun != 'empty':                                                     # Add the pruning if necessary
                    new_repr.add(prun)

            return Genetic_Pruning_Process.indiv_class(self.struc, self.objs_string, new_repr)

        return(indiv)

    # TODO Completar con el esquema general del algoritmo genético
    def genetic_optimization(self, seed):
        """
        Defines the whole optimization process
        """

        np.random.seed(seed)

        print("comienzo")
        print(self.population)
        for i in range(self.num_gen):
            new_pop = self.tournament()
            new_pop = self.pop_crossover()
            new_pop = [self.mutation(indiv) for indiv in new_pop]
            
            print(i)
            self.population = new_pop
        print("fin")
        return self.population





########################################################################################################################
########################################################################################################################
########################################################################################################################
########################################################################################################################



class Genetic_Pruning_Process_NSGA2(Genetic_Pruning_Process):

    indiv_class = Individual_NSGA2

    def __init__(self, struc, objs, num_gen, num_indiv, prob_cross, prob_mutation):
        Genetic_Pruning_Process.__init__(self, struc, objs, num_gen, num_indiv, prob_cross, prob_mutation)
        self.fronts = []
        self.domination_count = 0
        self.dominated_solutions = []

    def crowding_distance(self, front):
        if len(front) > 0:
            solutions_num = len(front)
            for individual in front:
                individual.crowding_distance = 0

            for m in range(len(front[0].objectives)):
                front.sort(key=lambda individual: individual.objectives[m])
                front[0].crowding_distance = 10**9
                front[solutions_num-1].crowding_distance = 10**9
                m_values = [individual.objectives[m] for individual in front]
                scale = max(m_values) - min(m_values)
                if scale == 0: scale = 1
                for i in range(1, solutions_num-1):
                    front[i].crowding_distance += (front[i+1].objectives[m] - front[i-1].objectives[m])/scale

    def fast_nondominated_sort(self):
        self.fronts = [[]]
        for individual in self.population:               #Establecimiento mejor frente e info de dominación para generar los demás
            individual.domination_count = 0
            individual.dominated_solutions = []
            for other_individual in self.population:
                if individual.dominates(other_individual):                  #Si la solución actual domina a la otra
                    individual.dominated_solutions.append(other_individual) #Se añade a su lista de soluciones dominadas
                elif other_individual.dominates(individual):                #Si no
                    individual.domination_count += 1                        #Aumentamos el contador de dominación
            if individual.domination_count == 0:                            #Si no es dominada por nadie
                individual.rank = 0
                self.fronts[0].append(individual)
        i = 0
        while len(self.fronts[i]) > 0:        #Mientras que haya soluciones en el frente actual considerado
            temp = []
            for individual in self.fronts[i]:
                for other_individual in individual.dominated_solutions:     #Para cada individuo dominado por la solución actual
                    other_individual.domination_count -= 1                  #Le quitamos 1 al contador
                    if other_individual.domination_count == 0:              #Si llega a 0 no hay sols que las dominen y entra en el siguiente frente
                        other_individual.rank = i+1
                        temp.append(other_individual)
            i = i+1
            self.fronts.append(temp)

    def tournament(self):
        """
        Applies tournament criterion over population, returning parents population.

        Parameters:
        - population: population of individuals to b

        Returns:
        - new_pop: parents population
        """

        self.fast_nondominated_sort()
        for front in self.fronts:
            self.crowding_distance(front)
        
        new_pop = []    # Population of nodes winning the tournament

        longi = len(self.population)
        for i in range(longi):                      # For each individual in the new population
            rand1 = np.random.randint(0, longi)     # Randomly select two distinct individuals
            rand2 = np.random.randint(0, longi)
            while rand1 == rand2:
                rand2 = np.random.randint(0, longi)

            # We select the node with the best rank. It there is none, we select the one with the best crowding distance
            best = None
            if self.population[rand1].rank < self.population[rand2].rank:
                best = self.population[rand1]
            elif self.population[rand1].rank > self.population[rand2].rank:
                best = self.population[rand2]
            else:
                if self.population[rand1].crowding_distance > self.population[rand2].crowding_distance:
                    best = rand1
                else:
                    best = rand2
            new_pop.append(best)

        return new_pop

    
    def genetic_optimization(self, seed):
        """
        Defines the whole optimization process
        """

        np.random.seed(seed)

        print("comienzo")
        print(self.population)
        for i in range(self.num_gen):
            new_pop = self.tournament()
            new_pop = self.pop_crossover()
            new_pop = [self.mutation(indiv) for indiv in new_pop]
            
            print(i)
            self.population = new_pop
        print("fin")

        self.fast_nondominated_sort()
        return self.fronts[0]                       # Returns the best individuals

